<h3>Introduction aux structures d'inclusion en PHP</h3>
<p>
    PHP offre plusieurs moyens d’inclure des fichiers dans votre script afin de <b>réutiliser le code</b> et/ou de <b>structurer 
    votre projet</b>. Ces instructions permettent de charger un fichier externe dans le fichier principal. 
    Voici une explication des différences entre <cite>require</cite>, <cite>require_once</cite>, <cite>include</cite>, 
    et <cite>include_once</cite>.
</p>
<h3>1. <span class="red">require</span></h3>
<p>
    L'instruction require inclut un fichier PHP. Si le fichier ne peut pas être inclus (par exemple, si le 
    chemin est incorrect), elle provoque une erreur fatale, et l'exécution du script s'arrête.
</p>
<p><b>Usage :</b></p>
<pre> require 'chemin/vers/fichier.php'; </pre>
<p>
    <b>Quand l'utiliser</b> : Lorsque <b>le fichier inclus est indispensable</b> pour le fonctionnement de votre 
    application (par exemple, un fichier de configuration).
</p>

<h3>2. <span class="red">require_once</span></h3>
<p>
    <cite>require_once</cite> fonctionne comme <cite>require</cite>, mais il vérifie d'abord si le fichier a déjà 
    été inclus. Si oui, il ne l'inclut pas une deuxième fois.
</p>
<p><b>Usage :</b></p>
<pre> require_once 'chemin/vers/fichier.php'; </pre>
<p>
    <b>Quand l'utiliser</b> : Lorsqu'il est <b>critique d'éviter une inclusion multiple d'un même fichier</b>, 
    ce qui pourrait provoquer des erreurs (par exemple, la redéclaration de fonctions ou de classes).
</p>

<h3>3. <span class="red">include</span></h3>
<p>
    L'instruction <cite>include</cite> fonctionne de manière similaire à require, mais elle gère les erreurs 
    de manière différente : si le fichier ne peut pas être inclus, une simple alerte (warning) est levée, 
    et le script continue son exécution.
</p>
<p><b>Usage :</b></p>
<pre> include 'chemin/vers/fichier.php'; </pre>
<p>
    <b>Quand l'utiliser</b> : Lorsque le fichier inclus est optionnel ou que le script peut fonctionner même en cas d'erreur 
    d'inclusion.
</p>

<h3>4. <span class="red">include_once</span></h3>
<p>
    <cite>include_once</cite> combine le comportement de include avec une vérification pour empêcher des inclusions 
    multiples.
</p>
<p><b>Usage :</b></p>
<pre> include_once 'chemin/vers/fichier.php'; </pre>
<p>
    <b>Quand l'utiliser</b> : Pour inclure un fichier optionnel tout en s'assurant qu'il n'est pas inclus 
    plusieurs fois.
</p>

<h3>5. Résumé des différences principales entre ces instructions</h3>
<table class="table">
    <tbody><tr><th><span>Instruction</span></th><th><span>Interrompt le script en cas d'échec ?</span></th><th><span>Empêche les inclusions multiples ?</span></th></tr><tr><td><code><span>require</span></code></td><td><span>Oui</span></td><td><span>Non</span></td></tr><tr><td><code><span>require_once</span></code></td><td><span>Oui</span></td><td><span>Oui</span></td></tr><tr><td><code><span>include</span></code></td><td><span>Non</span></td><td><span>Non</span></td></tr><tr><td><code><span>include_once</span></code></td><td><span>Non</span></td><td><span>Oui</span></td></tr></tbody>
</table>

<h3>6. Les bonnes pratiques : Structure de répertoires pour un projet PHP</h3>
<p>
    Une structure claire et logique pour un projet PHP facilite la maintenance, la lisibilité et l'évolutivité de votre 
    application. Voici un exemple, une proposition de structure typique pour débuter un projet 
    (cette structure est adaptable en fonction du projet)  :
</p>
<pre>
    projet/
    |— index.php           # Point d'entrée principal
    |— assets/             # Fichiers CSS, JS, images
    |   |— css/
    |   |— js/
    |   |— images/
    |— includes/          # Fichiers PHP réutilisables (header, footer, etc.)
    |— config/            # Fichiers de configuration
    |— classes/           # Classes PHP (POO)
    |— views/             # Fichiers de présentation (HTML avec PHP)
    |— logs/              # Journaux (logs) d'erreurs ou d'activité
    |— vendor/            # Bibliothèques tierces (via Composer)
    |— tests/             # Fichiers de tests unitaires
</pre>
<h5 class="mt-5"><b>Description des dossiers</b> : </h5>
<ol>
    <li> <b>index.php</b> : Point d'entrée principal de votre application. </li>
    <li> <b>assets/</b> : Contient les ressources front-end comme les fichiers CSS, JavaScript et les images. </li>
    <li> <b>includes/</b> : Regroupe les fichiers PHP réutilisables (comme header.php, footer.php, ou des fonctions communes). </li>
    <li> <b>config/</b> : Stocke les fichiers de configuration, comme les paramètres de connexion à la base de données. </li>
    <li> <b>classes/</b> : Contient les définitions de classes pour une application orientée objet. </li>
    <li> <b>views/</b> : Inclut les fichiers de présentation pour séparer la logique du code et le rendu visuel. </li>
    <li> <b>logs/</b> : Permet de consigner les journaux pour le débogage et le suivi des erreurs. </li>
    <li> <b>vendor/</b> : Contient les dépendances gérées par Composer (ou manuellement). </li>
    <li> <b>tests/</b> : Fichiers pour effectuer des tests unitaires ou d'intégration. </li>    
</ol>

<h3>7. Conseils supplémentaires</h3>
<ul>
    <li>Utilisez require_once pour les fichiers critiques comme la configuration ou les classes importantes.</li>
    <li>Privilégiez l’organisation et la lisibilité en évitant de mélanger les fichiers dans un même répertoire.</li>
    <li>Composer : Si votre projet devient complexe, envisagez d'utiliser Composer pour la gestion des dépendances et le chargement automatique (« autoloading »).</li>
    <li>Centralisez les inclusions : Un fichier principal comme bootstrap.php peut centraliser toutes les inclusions et initialisations nécessaires.</li>
</ul>
<p>En respectant ces bonnes pratiques, vous garantirez une base solide et évolutive pour votre projet PHP.</p>

<h3>8. La gestion des chemins (path) dans les projets PHP</h3>
<p>
    Gérer les chemins des ressources dans un projet PHP peut rapidement devenir complexe, surtout lorsque le projet grandit ou est 
    déployé dans différents environnements (développement, staging, production). Voici quelques bonnes pratiques pour 
    gérer efficacement les chemins des ressources :
</p>

<h4>1. Utiliser des constantes pour les chemins de base</h4>
<p>
    Définir une constante qui représente le chemin de base du projet, ce qui facilite la gestion des ressources. 
    Par exemple :
</p>
<textarea class="code-php">
    // fichier config.php
    define('BASE_URL', '/mon-projet/'); // ou '/' si le projet est à la racine
    define('ASSETS_URL', BASE_URL . 'assets/');
</textarea>
<p>
    Ensuite, vous pouvez inclure des ressources comme suit :
</p>
<textarea class="code-php">
    &lt;link rel="stylesheet" href="&lt;?= ASSETS_URL ?&gt;css/style.css"&gt;
    &lt;img src="&lt;?= ASSETS_URL ?&gt;images/logo.png" alt="Logo"&gt;    
</textarea>

<h4>2. Utiliser <cite>$_SERVER</cite> pour détecter la racine</h4>
<p>
    Si votre projet est déployé à différents niveaux (par exemple, sous-dossiers ou domaines), utilisez <cite>$_SERVER['DOCUMENT_ROOT']</cite> 
    ou <cite>dirname(__FILE__)</cite> pour définir dynamiquement les chemins :
</p>
<textarea class="code-php">
    define('BASE_PATH', dirname(__DIR__));
    define('BASE_URL', $_SERVER['REQUEST_SCHEME'] . '://' . $_SERVER['HTTP_HOST'] . '/mon-projet/');
</textarea>

<h4>3. Créer une fonction helper</h4>
<p>
    Encapsuler la génération de chemins dans une fonction pour une meilleure maintenabilité :
</p>
<textarea class="code-php">
    function asset($path) {
        return ASSETS_URL . $path;
    }    
</textarea>
<p>Vous pouvez l'utiliser ainsi :</p>
<textarea class="code-php">
    &lt;link rel="stylesheet" href="&lt;?= asset('css/style.css') ?&gt;"&gt;
    &lt;img src="&lt;?= asset('images/logo.png') ?&gt;" alt="Logo"&gt;  
</textarea>

<h4>5. Gérer les liens du menu de navigation</h4>
<p>
    Pour les liens dynamiques, vous pouvez utiliser une base pour construire les URL afin d'éviter les chemins relatifs cassés :
</p>
<textarea class="code-php">
    &lt;a href="&lt;?= BASE_URL ?&gt;home.php"&gt;Accueil&lt;/a&gt;
    &lt;a href="&lt;?= BASE_URL ?&gt;contact.php"&gt;Contact&lt;/a&gt;    
</textarea>


<h4>6. Configurations spécifiques à l’environnement</h4>
<p>
    Si votre projet est déployé sur plusieurs environnements (local, staging, production), configurez des variables 
    d’environnement via un fichier <cite>.env</cite> (à l’aide de <cite><a href="https://github.com/vlucas/phpdotenv" target="_blank">vlucas/phpdotenv</a></cite>, par exemple) :
</p>
<p>Exemple d'un fichier <cite>.env</cite> :</p>
<textarea class="code-php">
    BASE_URL="http://localhost/mon-projet/"
    ASSETS_URL="http://localhost/mon-projet/assets/"
</textarea>
<p>
    Ajoutez la configuration de votre application dans un fichier .env à la racine de votre projet. 
    Assurez-vous que le fichier <cite>.env</cite> est ajouté à votre <cite>.gitignore</cite> afin qu'il ne soit pas 
    versionné dans le code.
</p>
<p>
    De manière générale, créez un fichier nommé <cite>.env.example</cite> et insérez-le dans votre projet. 
    Ce fichier doit contenir les variables ENV dont vous avez besoin, mais les valeurs doivent être soit vides, soit remplies avec des 
    données fictives. L'idée est de faire savoir aux gens quelles sont les variables nécessaires, mais de ne pas leur donner les 
    valeurs de production sensibles.
</p>
<p>Vous pouvez ensuite charger .env dans votre application avec :</p>
<textarea class="code-php">
    $dotenv = Dotenv\Dotenv::createImmutable(__DIR__);
    $dotenv->load();      
</textarea>
<p>Suite à cela, toutes les variables définies sont désormais disponibles dans les tableaux super-globaux <cite>$_ENV</cite> et <cite>$_SERVER</cite>.</p>
<textarea class="code-php">
    $s3_bucket = $_ENV['S3_BUCKET'];
    $s3_bucket = $_SERVER['S3_BUCKET'];
</textarea>

<h4>7. Utiliser un framework</h4>
<p>
    Si votre projet PHP devient complexe, envisagez d’utiliser un framework comme Laravel ou Symfony, qui gèrent les chemins des 
    ressources et les routes automatiquement.
</p>
<p class="mt-5">
    En bref, ces stratégies combinées permettent de rendre votre projet plus organisé, maintenable, et adaptable à différents environnements.
</p>