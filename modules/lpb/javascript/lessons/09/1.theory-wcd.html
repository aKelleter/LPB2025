<p>
    Le type <cite>Symbol</cite> en Javascript est un type de donn√©es primitif introduit avec ES6 (ES2015). 
    Il est utilis√© pour cr√©er des identifiants uniques. Voici une explication d√©taill√©e sur comment 
    l'utiliser et ce que vous pouvez faire avec. 
</p>
<h3>Caract√©ristiques principales de <cite>Symbol</cite></h3>
<p>
    <b>1. Identifiants uniques</b> : <br>
    Chaque Symbol est unique, m√™me si deux symboles sont cr√©√©s avec la m√™me description.
    <textarea class="code-php">
        let sym1 = Symbol("id");
        let sym2 = Symbol("id");
        console.log(sym1 === sym2); // false
    </textarea>
</p>
<p>
    <b>2. Pas de conversion implicite en cha√Ænes</b> : <br>
    Les <cite>Symbol</cite> ne peuvent pas √™tre convertis automatiquement en une cha√Æne. 
    Cela √©vite des conflits accidentels.
    <textarea class="code-php">
        let sym = Symbol("example");
        console.log("Symbole : " + sym); // TypeError
        console.log(String(sym));       // Symbole : Symbol(example)
    </textarea>
</p>
<h3>Cas d'utilisation de <cite>Symbol</cite></h3>
<p>
    <b>1. Cr√©er des cl√©s d'objet uniques</b> : <br>
    Les <cite>Symbol</cite> sont souvent utilis√©s comme cl√©s d'objet pour garantir que les propri√©t√©s ne sont pas en conflit avec 
    d'autres propri√©t√©s.
    <textarea class="code-php">
        let id = Symbol("id");
        let user = {
            name: "John",
            [id]: 12345 // Cl√© unique (Les crochets [ ] permettent d'utiliser une expression (comme un symbole) comme cl√©.)
        };
        console.log(user[id]); // 12345
    </textarea>
    Avantage : m√™me si quelqu'un ajoute une autre propri√©t√© id √† l'objet, elle ne perturbera pas la propri√©t√© symbolique.
</p>
<p>
    <b>2. Ajouter des propri√©t√©s non-√©num√©rables</b> : <br>
        Les propri√©t√©s symboliques ne sont pas accessibles par les boucles comme <cite>for...in</cite> ou <cite>Object.keys</cite>. 
        Elles restent "cach√©es" par d√©faut.
    <textarea class="code-php">
        let hidden = Symbol("hidden");
        let obj = {
            visible: "This is visible",
            [hidden]: "This is hidden"
        };
        
        console.log(Object.keys(obj)); // ["visible"]
        console.log(obj[hidden]);      // "This is hidden"        
    </textarea>    
</p>
<p>
    <b>3. Utiliser des <cite>Symbol globaux</cite></b> : <br>
        Vous pouvez utiliser <cite>Symbol.for(key)</cite> pour cr√©er ou r√©cup√©rer un <cite>Symbol</cite> global. Cela permet de partager 
        un <cite>Symbol</cite> entre diff√©rents fichiers ou modules.
    <textarea class="code-php">
        let sym1 = Symbol.for("shared");
        let sym2 = Symbol.for("shared");
        console.log(sym1 === sym2); // true
    </textarea>
    <br> Avec Symbol.keyFor(), vous pouvez r√©cup√©rer la cl√© d'un Symbol global :
    <textarea class="code-php">
        console.log(Symbol.keyFor(sym1)); // "shared"
    </textarea>    
</p>
<p>
    <b>4. D√©finir des comportements personnalis√©s dans des objets</b> : <br>
        Certains <cite>Symbol</cite> sont pr√©d√©finis en JavaScript pour personnaliser le comportement des objets. Exemples courants :
    <textarea class="code-php">
        let iterableObj = {
            items: [1, 2, 3],
            [Symbol.iterator]() {
                let i = 0;
                return {
                    next: () => ({
                        value: this.items[i++],
                        done: i > this.items.length
                    })
                };
            }
        };
        
        for (let item of iterableObj) {
            console.log(item); // 1, 2, 3
        }        
    </textarea>
    <p>
        <b><u>Explications du code ci-dessus</u></b> : <br>       
    
        Le code permet de rendre un objet it√©rable en d√©finissant une m√©thode sp√©ciale avec le symbole pr√©d√©fini <cite>Symbol.iterator</cite>.
        Examinons-le en d√©tail‚ÄØ: <br>
        <b>Le r√¥le de Symbol.iterator</b> <br>
        <cite>Symbol.iterator</cite> est un symbole pr√©d√©fini en Javascript utilis√© pour rendre un objet it√©rable.
        Quand un objet impl√©mente une m√©thode associ√©e √† <cite>Symbol.iterator</cite>, cet objet peut √™tre parcouru avec des structures 
        comme <cite>for...of</cite>, <cite>spread (...)</cite>, ou des m√©thodes comme <cite>Array.from</cite>.
    </p>
    <p>
        <b>D√©composition ligne par ligne</b> : <br>
    </p>
    <ol>
        <li>
            <p><strong>Propri√©t√© <code>items</code></strong> :<br>C'est un tableau <code>[1, 2, 3]</code> stock√© comme une propri√©t√© de l'objet <code>iterableObj</code>.</p>
        </li>
        <li>
            <p><strong>D√©finition de <code>Symbol.iterator</code></strong> :</p>
            <ul>
                <li>La m√©thode associ√©e √† <code>Symbol.iterator</code> transforme l'objet <code>iterableObj</code> en un <strong>it√©rateur</strong>.</li>
                <li>Elle renvoie un objet avec une m√©thode <code>next</code> qui suit le protocole des it√©rateurs.</li>
            </ul>
        </li>
        <li>
            <p><strong>La m√©thode <code>next</code></strong> :</p>
            <ul>
                <li>√Ä chaque appel, <code>next</code> :
                    <ul>
                        <li>Fournit la propri√©t√© <code>value</code>, qui est l'√©l√©ment suivant du tableau <code>items</code>.</li>
                        <li>Fournit la propri√©t√© <code>done</code>, qui indique si l'it√©ration est termin√©e (<code>true</code>).</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <p><strong>Comportement de l'it√©rateur</strong> :</p>
            <ul>
                <li>√Ä chaque it√©ration, <code>i</code> est incr√©ment√©.</li>
                <li>Lorsque <code>i</code> d√©passe la longueur du tableau, <code>done</code> passe √† <code>true</code>, signalant la fin de l'it√©ration.</li>
            </ul>
        </li>
    </ol>  
    <p>
        <b>Utilisation</b> : <br>
    </p> 
    <textarea class="code-php">
        // Avec une boucle for...of
        for (let value of iterableObj) {
            console.log(value); // 1, 2, 3
        } 
        
        // Avec l'op√©rateur de d√©composition (...) spread
        let array = [...iterableObj];
        console.log(array); // [1, 2, 3]

        // Avec Array.from
        let array = Array.from(iterableObj);
        console.log(array); // [1, 2, 3]
    </textarea>
    <p>
        <b>Explication du protocole des it√©rateurs</b> <br>
        Un it√©rateur en JavaScript doit avoir : <br>
            1. Une m√©thode <cite>next</cite> qui renvoie un objet. <br>
            2. Cet objet doit avoir deux propri√©t√©s : <br>
                - <cite>value</cite> : La valeur courante de l'it√©ration. <br>
                - <cite>done</cite> : Un bool√©en indiquant si l'it√©ration est termin√©e (true) ou non (false). <br>
    </p>
</p>
<h3>Quand utiliser <cite>Symbol</cite> ?</h3>
<ul>
    <li>Lorsque vous devez garantir l'unicit√© des cl√©s dans un objet.</li>
    <li>Pour ajouter des propri√©t√©s "priv√©es" ou cach√©es √† des objets.</li>
    <li>Pour utiliser ou personnaliser des fonctionnalit√©s avanc√©es via des <cite>Symbol</cite> pr√©d√©finis.</li>
    <li>Lorsque vous travaillez avec des modules ou des biblioth√®ques pour √©viter des conflits avec des cl√©s d'objet existantes.</li>
</ul>
Les <cite>Symbol</cite> sont donc puissants pour des cas avanc√©s ou pour √©crire du code plus robuste et modulable. üòä